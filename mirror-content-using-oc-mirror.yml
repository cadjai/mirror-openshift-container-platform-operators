#!/usr/local/bin/ansible-playbook --inventory=inventory
- name: 'Mirror content using oc-mirror | mirror-operators.yml'
  hosts: localhost
  vars:
    ansible_python_interpreter: /usr/bin/python3.6
    module: "content-mirror"
    ansible_name_module: " Miror Content using oc-mirror | {{ module }}"

  vars_files:
    - 'vars/vault.yml'
    - 'vars/registry.yml'
  
  pre_tasks:
    - name: Ensure required oc-mirror binary is installed on host
      when:
        - not oc_mirror_cli is defined or oc_mirror_cli == ''
      block:
        - name: '{{ ansible_name_module }} | command:which | Check if oc-mirror is installed'
          ansible.builtin.shell: >
            which oc-mirror
          ignore_errors: yes
          register: ocmirror_binary

        - name: '{{ ansible_name_module }} | set_fact |  oc_mirror_cli'
          ansible.builtin.set_fact:
            oc_mirror_cli: "{{ ocmirror_binary.stdout }}"
          when:
            - ocmirror_binary is defined
            - ocmirror_binary.rc is defined
            - ocmirror_binary.rc == 0
            - ocmirror_binary.stdout is defined
            - ocmirror_binary.stdout != ''

    - name: '{{ ansible_name_module }} | command:which | Check if podman is installed'
      block:
        - name: '{{ ansible_name_module }} | command:which | Check if oc-mirror is installed'
          ansible.builtin.shell: >
            which podman
          ignore_errors: yes
          register: podman_binary

        - name: '{{ ansible_name_module }} | set_fact |  podman_cli'
          ansible.builtin.set_fact:
            podman_cli: "{{ podman_binary.stdout }}"
          when:
            - podman_binary is defined
            - podman_binary.rc is defined
            - podman_binary.rc == 0
            - podman_binary.stdout is defined
            - podman_binary.stdout != ''

  tasks:
    - name: '{{ ansible_name_module }} | shell | find catalogs from imageset config file '
      ansible.builtin.shell: >
        grep catalog {{ imageset_config_file }} | awk '{print $3}'
      register: cat_src_out

    - name: '{{ ansible_name_module }} | Print Catalog Sources output'
      ansible.builtin.debug:
        var: cat_src_out
        verbosity: 2

    - name: '{{ ansible_name_module }} | podman:login | Login to quay container registry'
      no_log: true
      ansible.builtin.command: >
          {{ podman_cli }} login -u {{ default_operator_registry_username }} \
         -p {{ default_operator_registry_password }} \
         --authfile {{ hostvars[inventory_hostname].ansible_env.HOME }}/.docker/config.json \
          {{ default_operator_registry }}
      register: authfile_created

    - name: '{{ ansible_name_module }} | podman:login | Login to extra registry'
      no_log: true
      ansible.builtin.command: >
         {{ podman_cli }} login -u {{ default_operator_registry_username }} \
          -p {{ default_operator_registry_password }} \
          --authfile {{ hostvars[inventory_hostname].ansible_env.HOME }}/.docker/config.json \
          {{ item.split('/')[0] }}
      loop: "{{ cat_src_out.stdout_lines }}"

    - name: '{{ ansible_name_module }} | set_fact |  authfile for registry'
      ansible.builtin.set_fact:
        operator_registry_pull_secret_file: "{{ hostvars[inventory_hostname].ansible_env.HOME }}/.docker/config.json"

    - name: '{{ ansible_name_module }} | file:directory | Ensure the images staging directory exist'
      become: yes
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: 0777
      loop:
        - "{{ registry_container_dir }}"
        - "{{ dir_bundle_location }}"

    - name: '{{ ansible_name_module }} | podman:login | Login to extra registry'
      ansible.builtin.shell: >
        {{ podman_cli }} ps -a | grep  {{ registry_container_name }}  | awk '{print $NF}'
      ignore_errors: yes
      register: container_status

    - name: '{{ ansible_name_module }} | podman:run | Start registry container '
      ansible.builtin.command: >
        {{ podman_cli }}  run -d --name {{ registry_container_name }} \
          -p 5000:5000 -v {{ registry_container_dir }}:/var/lib/registry \
          {{ registry_container_image }}
       when:
        - container_status is defined
        - container_status.rc is defined
        - container_status.rc == 0
        - container_status.stdout is defined
        - container_status.stdout == '' or  not registry_container_name in container_status.stdout
      register: container_start_out

    - name: '{{ ansible_name_module }} | Mirror content using the oc-mirror plugin'
      ansible.builtin.command: >
        {{ oc_mirror_cli }} --config {{ imageset_config_file }} file://{{ dir_bundle_location }} -v5
      register: content_mirrored

    - name:  '{{ ansible_name_module }} | Generate content manifest file for temp container registry to be used as placeholder for later processing'
      ansible.builtin.command: >
        {{ oc_mirror_cli }} --config {{ imageset_config_file }} --from {{ dir_bundle_location }}/{{ bundle_name | d('mirror_seq1_000000.tar', true) }}  docker://localhost:5000 --dest-skip-tls --manifests-only -v5
      register: manifests_retrieved

    - name: '{{ ansible_name_module }} | Print Manifest Retrieval output'
      ansible.builtin.debug:
        var: manifests_retrieved
        verbosity: 2

    - name: '{{ ansible_name_module }} | set_fact |  manifest_result_folder'
      ansible.builtin.set_fact:
        manifest_result_folder: "{{ (manifests_retrieved.stdout_lines[-1]).split('Writing ICSP manifests to ')[1] }}"

    - name: '{{ ansible_name_module }} | Print Manifest Results output'
      ansible.builtin.debug:
        var: manifest_result_folder
        verbosity: 2

###################### Copy manifest files to location to be pushed to gitab
    - name: '{{ ansible_name_module }} | copy manifest files to source repo location'
      when:
        - operator_content_type is defined
        - operator_content_type | bool
      block:
        - name: '{{ ansible_name_module }} | file:directory | Ensure the manifest directory exist'
          ansible.builtin.file:
            path: "{{ playbook_dir }}/manifests/operators/"
            state: directory
            mode: 0755

        - name: '{{ ansible_name_module }} | copy | copy icsp manifest file '
          ansible.builtin.copy:
            src: "{{ playbook_dir }}/{{ manifest_result_folder }}/imageContentSourcePolicy.yaml"
            dest: "{{ playbook_dir }}/manifests/operators/{{ icsp_filename | d('imageContentSourcePolicy.yaml', true) }}"
            force: yes
          register: icsp_copied

        - name: '{{ ansible_name_module }} | copy | copy icsp manifest file '
          ansible.builtin.copy:
            src: "{{ playbook_dir }}/{{ manifest_result_folder }}/imageContentSourcePolicy.yaml"
            dest: "{{ playbook_dir }}/manifests/operators/{{ olm_icsp_filename | d('olm-icsp-registry.yaml', true) }}"
            force: yes
          register: olm_icsp_copied


        - name: '{{ ansible_name_module }} | copy | copy icsp manifest file '
          ansible.builtin.copy:
            src: "{{ playbook_dir }}/{{ manifest_result_folder }}/imageContentSourcePolicy.yaml"
            dest: "{{ playbook_dir }}/manifests/operators/{{ olm_icsp_filename | d('olm-icsp-registry.yaml', true) }}"
            force: yes
          register: olm_icsp_copied

        - name: '{{ ansible_name_module }} | copy | copy mapping.txt file '
          ansible.builtin.copy:
            src: "{{ playbook_dir }}/{{ manifest_result_folder }}/mapping.txt"
            dest: "{{ playbook_dir }}/manifests/operators/{{ mapping_filename |d('mapping.txt', true) }}"
            force: yes
          register: mapping_copied

        - name: '{{ ansible_name_module }} | copy | copy mapping.txt file '
          ansible.builtin.copy:
            src: "{{ playbook_dir }}/{{ manifest_result_folder }}/mapping.txt"
            dest: "{{ playbook_dir }}/manifests/operators/{{ reg_mapping_filename | d('mapping-registry.txt', true) }}"
            force: yes
          register: reg_mapping_copied

        - name: '{{ ansible_name_module }} | replace | file name '
          ansible.builtin.replace:
            path: "{{ playbook_dir }}/manifests/operators/{{ olm_icsp_filename | d('olm-icsp-registry.yaml', true) }}"
            regexp: 'operator-0'
            replace: '{{ icsp_name | d("dpaas-operators", true) }}'

        - name: '{{ ansible_name_module }} | replace | file name '
          ansible.builtin.replace:
            path: "{{ playbook_dir }}/manifests/operators/{{ olm_icsp_filename | d('olm-icsp-registry.yaml', true) }}"
            regexp: 'localhost:5000'
            replace: '{{ registry_host_fqdn }}/{{ operator_local_repository }}'

        - name: '{{ ansible_name_module }} | replace | file name '
          ansible.builtin.replace:
            path: "{{ playbook_dir }}/manifests/operators/{{ reg_mapping_filename | d('mapping-registry.txt', true) }}"
            regexp: 'localhost:5000'
            replace: '{{ registry_host_fqdn }}/{{ operator_local_repository }}'

        ######### Copy rh-catalog-source manifest file to location to be pushed to gitab
        - name: '{{ ansible_name_module }} | template | Copy catalogSource template to staging location'
          ansible.builtin.template:
            src: "templates/catalogsource.yaml.j2"
            dest: "{{ playbook_dir }}/manifests/operators/{{ operator_catalog_name }}-catalogsource.yaml"
            force: yes
          vars:
            operator_catalog_name: "{{  catalog_name if catalog_name is defined and catalog_name != '' else (((item.split('/')[-1]).split(':')[0]).split('-index')[0] + 's') }}"
            operator_repository: "{{ item.split('/')[1:-1] | join('/') }}"
            operator_catalog_index: "{{ (catalog_name + '-index') if catalog_name is defined and catalog_name != '' else (item.split('/')[-1]).split(':')[0] }}"
            operator_catalog_index_tag: "{{ (item.split('/')[-1]).split(':')[1] }}"
            registry_host: "localhost:5000"
            operator_catalog_publisher: "Red Hat"
          loop: "{{ cat_src_out.stdout_lines }}"
          when:
            - cat_src_out is defined
            - cat_src_out.stdout_lines is defined
            - cat_src_out.stdout_lines | length > 0
          register: cat_src_copied

        - name: '{{ ansible_name_module }} | Print Catalog Sources output'
          ansible.builtin.debug:
            var: cat_src_copied
            verbosity: 2

        - name: '{{ ansible_name_module }} | template | Copy CatalogSource template to staging location'
          ansible.builtin.template:
            src: "templates/catalogsource.yaml.j2"
            dest: "{{ playbook_dir }}/manifests/operators/{{ operator_catalog_name }}-catalogsource-registry.yaml"
            force: yes
          vars:
            operator_catalog_name: "{{ catalog_name if catalog_name is defined and catalog_name != '' else (((item.split('/')[-1]).split(':')[0]).split('-index')[0] + 's') }}"
            operator_repository: "{{ operator_local_repository }}/{{ item.split('/')[1:-1]  | join('/') }}"
            operator_catalog_index: "{{ (catalog_name + '-index') if catalog_name is defined and catalog_name != '' else (item.split('/')[-1]).split(':')[0] }}"
            operator_catalog_index_tag: "{{ (item.split('/')[-1]).split(':')[1] }}"
            registry_host: "{{ registry_host_fqdn }}"
            operator_catalog_publisher: "Red Hat"
          loop: "{{ cat_src_out.stdout_lines }}"
          when:
            - cat_src_out is defined
            - cat_src_out.stdout_lines is defined
            - cat_src_out.stdout_lines | length > 0
          register: cat_src_art_copied

        - name: '{{ ansible_name_module }} | Print Catalog Sources output'
          ansible.builtin.debug:
            var: cat_src_art_copied
            verbosity: 2

        - name: '{{ ansible_name_module }} | file | remove workspace directory'
          ansible.builtin.file:
            path: "{{ manifest_result_folder.split('/')[0] }}"
            state: absent
          when:
            - cat_src_art_copied is defined
            - cat_src_copied is defined
          register: wrkspace_dir_removed

