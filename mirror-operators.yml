#!/usr/local/bin/ansible-playbook --inventory=inventory
- name: ' Konductor | Provision UPI Infra | mirror-operators.yml'
  hosts: localhost
  vars:
    ansible_python_interpreter: /usr/bin/python3.6
    module: "mirror-operators"
    ansible_name_module: " Konductor | Provision UPI Infra | {{ module }}"
  vars_files:
    - 'vars/vault.yml'
    - 'vars/registry.yml'

  pre_tasks:
    - name: Install required depencies 
      become: yes
      yum:
        name:
          - python3-libselinux 
        state: present

    - name: '{{ ansible_name_module }} | pip install | install required module'
      pip:
        name: jinja2

  tasks:
    - name: '{{ ansible_name_module }} | Download, install and configure grpcurl '
      when:
        - pull_all is defined
        - pull_all | bool
      block:
        - name: '{{ ansible_name_module }} | get_url | '
          get_url:
            url: "{{ grpcurl_binary_download_url }}"
            dest: "{{ temp_dir }}"
            mode: 0755
            force: true
            validate_certs: false
          register: grpcurl_downloaded

        - name: '{{ ansible_name_module }} | unarchive | unpack grpcurl archive'
          become: yes
          unarchive:
            src: "{{ temp_dir }}/{{ grpcurl_binary_downloaded_artifact }}"
            dest: "{{  grpcurl_binary | dirname }}"
            mode: 0755
            remote_src: true
            validate_certs: false
          register: grpcurl_archive_installed

    - name: '{{ ansible_name_module }} | file:directory | Ensure all directory exist'
      command: >
        podman rm -f {{ registry_container_name }}
      ignore_errors: yes
      register: registry_container_removed

    - name: '{{ ansible_name_module }} | file:directory | Ensure all directory exist'
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - "{{ registry_container_dir }}"
        - "{{ dir_bundle_location }}"
        - "{{ dir_bundle_staging }}"
        - "{{ dir_bundle_staging }}/run"
        - "{{ dir_bundle_staging }}/scripts"

    - name: '{{ ansible_name_module }} | Download, install and configure opm '
      when:
        - install_opm is defined
        - install_opm | bool
      block:
        - name: '{{ ansible_name_module }} | get_url | download opm binary'
          get_url:
            url: "{{ opm_binary_download_url }}"
            dest: "{{ temp_dir }}"
            mode: 0755
            force: true
            validate_certs: false
          register: opm_downloaded

        - name: '{{ ansible_name_module }} | unarchive | unpack opm archive'
          become: yes
          unarchive:
            src: "{{ temp_dir }}/{{ opm_binary_downloaded_artifact }}"
            dest: "{{  opm_binary | dirname }}"
            mode: 0755
            remote_src: true
            validate_certs: false
          register: opm_archive_installed

        - name: '{{ ansible_name_module }} | copy | copy opm binary to {{ dir_bundle_staging }}/run '
          copy:
            src: "{{ opm_binary }}"
            dest: "{{ dir_bundle_staging }}/run/{{ opm_binary | basename }}"
            force: yes
            mode: '0755'
          register: opm_archive_copied

    - name: '{{ ansible_name_module }} | Generate list of operator for each index'
      when:
        - pull_all is defined
        - pull_all | bool 
        - item.key is defined and item.key != ""
        - item.value.mirror is defined and item.value.mirror | bool
        - item.value.source is defined and item.value.source != ""
        - item.value.host_port is defined and item.value.host_port|int > 0
        - item.value.container_port is defined and item.value.container_port|int > 0
      block:
        - name: '{{ ansible_name_module }} | podman:run | Start operator-index container '
          command: podman run -d --name operator_collector_{{ item.key  }} \
            -p {{ item.value.host_port }}:{{ item.value.container_port }}  {{ item.value.source }}
          with_dict:
            - "{{ operator_registries_to_mirror }}"

        - name: '{{ ansible_name_module }} | Create Package index '
          shell: >
            grpcurl -plaintext localhost:{{ item.value.host_port }} api.Registry/ListPackages \
            > "{{ dir_bundle_location | d('/tmp') }}/packages-{{ item.key }}.out"
          with_dict:
            - "{{ operator_registries_to_mirror }}"
          register: pkg_idx_out

        - name: '{{ ansible_name_module }} | podman:rm | Remove operator-index container '
          command: podman rm -f operator_collector_{{ item.key }}
          with_dict:
            - "{{ operator_registries_to_mirror }}"

        - name: '{{ ansible_name_module }} | cat | derive operator list from package manifest file '
          shell: cat "{{ dir_bundle_location | d('/tmp') }}/packages-{{ item.key }}.out" | jq .name | sed -e 's~"~~g'  > {{ dir_bundle_staging }}/{{ item.key }}
          with_dict:
            - "{{ operator_registries_to_mirror }}"
          register: operator_list_raw

    - name: '{{ ansible_name_module }} | podman:login | Login to RH container registry'
      no_log: true
      command: >
         podman login -u {{ default_operator_registry_username }} \
         -p {{ default_operator_registry_password }} \
         --authfile {{ hostvars[inventory_hostname].ansible_env.HOME }}/.docker/oprconfig.json \
          {{ default_operator_registry }}
      register: authfile_created

    - name: '{{ ansible_name_module }} | podman:login | Login to extra registry'
      no_log: true
      command: >
        podman login -u {{ default_operator_registry_username }} \
          -p {{ default_operator_registry_password }} \
          --authfile {{ hostvars[inventory_hostname].ansible_env.HOME }}/.docker/oprconfig.json \
          {{ item.value.image_registry }}
      with_dict:
        - "{{ operator_registries_to_mirror }}"
      when:
        - item.key is defined and item.key != ""
        - item.value.mirror is defined and item.value.mirror | bool
        - item.value.source is defined and item.value.source != ""
        - item.value.image_registry is defined and item.value.image_registry != ""

    - name: '{{ ansible_name_module }} | file |  set permission on authfile for registry'
      file:
        path: '{{ hostvars[inventory_hostname].ansible_env.HOME }}/.docker/oprconfig.json'
        mode: '0644'

    - name: '{{ ansible_name_module }} | set_fact |  authfile for registry'
      set_fact:
        operator_registry_pull_secret_file: "{{ hostvars[inventory_hostname].ansible_env.HOME }}/.docker/oprconfig.json"

    - name: '{{ ansible_name_module }} | file:directory | Ensure the images staging directory exist'
      file:
        path: "{{ item }}"
        state: directory
        mode: 0755
      loop:
        - "{{ dir_bundle_staging }}"
        - "{{ registry_container_dir }}"

    - name: '{{ ansible_name_module }} | podman:run | Start registry container '
      command: podman run -d --name {{ registry_container_name }} \
        -p 5000:5000 -v {{ registry_container_dir }}:/var/lib/registry:z \
          {{ registry_container_image }}

    - name: '{{ ansible_name_module }} | copy | copy content template files to staging location '
      copy:
        src: "{{ item }}"
        dest: "{{ dir_bundle_staging }}/{{ item | basename }}"
        force: yes
        mode: 0644
      with_items:
        - openshift-disconnected-operators/known-bad-images
        - openshift-disconnected-operators/image-content-source-template
        - openshift-disconnected-operators/catalog-source-template

    - name: '{{ ansible_name_module }} | copy | copy python modules into the script directory for execution '
      copy:
        src: "{{ item }}"
        dest: "{{ dir_bundle_staging }}/scripts/{{ item | basename }}"
        force: yes
        mode: '0755'
      with_items:
        - openshift-disconnected-operators/mirror-operator-catalogue.py
        - openshift-disconnected-operators/upgradepath.py

    - name: '{{ ansible_name_module }} | shell:echo | create a line separated list of the items to mirror 1 of 2'
      shell: echo {{ item.value.mirrored_operator_list }} > {{ dir_bundle_staging }}/{{ item.key }}
      with_dict:
        - "{{ operator_registries_to_mirror }}"
      when:
        - not pull_all is defined or not pull_all | bool
        - item.key is defined and item.key != ""
        - item.value.mirror is defined and item.value.mirror | bool
        - item.value.source is defined and item.value.source != ""
        - item.value.mirrored_operator_list is defined and item.value.mirrored_operator_list != ""

    - name: '{{ ansible_name_module }} | shell:sed | create a line separated list of the items to mirror 2 of 2'
      shell: sed -i $'s/,/\\\n/g' {{ dir_bundle_staging }}/{{ item.key }}
      with_dict:
        - "{{ operator_registries_to_mirror }}"
      when:
        - not pull_all is defined or not pull_all | bool
        - item.key is defined and item.key != ""
        - item.value.mirror is defined and item.value.mirror | bool
        - item.value.source is defined and item.value.source != ""
        - item.value.mirrored_operator_list is defined and item.value.mirrored_operator_list != ""

    - name: '{{ ansible_name_module }} | file:directory | ensure ouput directory exits for each of indices being processed'
      file:
        path: "{{ dir_bundle_staging }}/{{ item.key }}-publish"
        state: directory
        mode: 0755
      with_dict:
        - "{{ operator_registries_to_mirror }}"
      when:
        - item.key is defined and item.key != ""
        - item.value.mirror is defined and item.value.mirror | bool
        - item.value.source is defined and item.value.source != ""
        - item.value.mirrored_operator_list is defined and item.value.mirrored_operator_list != ""

    - name: Mirror operators using Arvin's python script
      script: >
        {{ dir_bundle_staging }}/scripts/mirror-operator-catalogue.py \
              --catalog-version=1.0.0 \
              --authfile={{ operator_registry_pull_secret_file }} \
              --registry-olm=localhost:5000 \
              --registry-catalog=localhost:5000 \
              --icsp-scope=namespace \
              --run-dir={{ dir_bundle_staging }} \
              --operator-image-name={{ item.key }} \
              --operator-catalog-image-url={{ item.value.source.split(':')[0] }}  \
              --opm-path={{ opm_binary }} \
              --custom-operator-catalog-name=custom-{{ item.key }} \
              --oc-cli-path={{ openshift_cli }} \
              --ocp-version={{ ocp_release_version }} \
              --output={{ item.key }}-publish \
              --operator-channel={{ item.value.source.split(':')[1] }} \
              --operator-file={{ dir_bundle_staging }}/{{ item.key }}
      args:
        executable: python3
        chdir: "{{ dir_bundle_staging }}/scripts/"
      environment:
        - PYTHONPATH: "{{ dir_bundle_staging }}/scripts/"
      with_dict:
        - "{{ operator_registries_to_mirror }}"
      when:
        - item.key is defined and item.key != ""
        - item.value.mirror is defined and item.value.mirror | bool
        - item.value.source is defined and item.value.source != ""

    - name: '{{ ansible_name_module }} | block | copy manifest files to container storage location'
      when:
        - bundle is defined
        - bundle | bool
      block:
        - name: '{{ ansible_name_module }} | command: cp | copy manifest files '
          copy:
            src: "{{ dir_bundle_staging }}/{{ item.key }}-publish"
            dest: "{{ registry_container_dir }}"
            force: yes
          with_dict:
            - "{{ operator_registries_to_mirror }}"
          when:
            - item.key is defined and item.key != ""
            - item.value.mirror is defined and item.value.mirror | bool
            - item.value.source is defined and item.value.source != ""

        - name: '{{ ansible_name_module }} | archive:xz | create operator image bundle '
          become: yes
          command: >
            tar -c --use-compress-program='pigz -9' -v \
              -f {{ dir_bundle_location }}/{{ bundle_file_name }} \
              -C {{ registry_container_dir }} .
          args:
            creates: "{{ dir_bundle_location }}/{{ bundle_file_name }}"
            warn: false
            chdir: "{{ registry_container_dir }}/"
